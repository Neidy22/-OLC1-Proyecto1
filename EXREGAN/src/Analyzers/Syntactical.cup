//importaciones
package Analyzers;
import Main.EXREGAN;
import Objects.*;
import ui.*;
import java_cup.runtime.*;

parser code
{:
    
    //metodos para controlar el arbol de expresiones
    public static int ids = 0;
    public static AST rootT;

    //metodo al que se llama automaticamente ante algun error sintactico
    public void syntax_error(Symbol s)
    {
        String lexema = s.value.toString();
        int fila = s.right;
        int columna = s.left;

        System.out.println("!!!!!!! Error Sintactico Recuperado !!!!!!!!!");
        System.out.println("\t\tLexema: "+lexema);
        System.out.println("\t\tFila: "+fila);
        System.out.println("\t\tColumna: "+columna);
        
        TError tmp = new TError("Sintactico",lexema,"Caracter no esperado",fila,columna);
        EXREGAN.errores.add(tmp);
    }

    //Metodo al que se llama en el momento en que ya no es posible una recuperaci칩n
    public  void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {
        String lexema = s.value.toString();
        int fila = s.right;
        int columna = s.left;

        System.out.println("!!!!!!! Error Sintactico, Panic Mode !!!!!!!!!");
        System.out.println("\t\tLexema: "+lexema);
        System.out.println("\t\tFila: "+fila);
        System.out.println("\t\tColumna: "+columna);
        
        TError tmp = new TError("Sintactico",lexema,"Caracter no esperado",fila,columna);
        EXREGAN.errores.add(tmp);
        
    }
:}


//DEFINICION DE LOS TERMINALES 
//expresiones compuestas
terminal String comment, multicomment, stringVal, id;

//operadores de las expresiones 
terminal String operatorAnd, operatorOr, operatorZeroMore, operatorOneMore, operatorZeroOne;

//simbolos
terminal String separator, comma, virgulilla, leftCurlyB, rightCurlyB, semicolon, colon, arrow, asciiChar, specialChar;

//reservadas
terminal String conj;

//DEFINICION DE LOS NO TERMINALES
non terminal INICIO, PROGRAMBODY, DEFINITION, EVALUATION, CONJUNTO, EXPRG, NOTATION, LISTVAL, PREFIXREGEX, ASCIIS; 

//PRECEDENCIAS
precedence left operatorOr;
precedence left operatorAnd; 

//le indico  con cu치l palabra reservada va a comenzar la gram치tica
start with INICIO;

INICIO ::= leftCurlyB PROGRAMBODY
        |  comment INICIO
        |  multicomment INICIO;

         

PROGRAMBODY ::= comment PROGRAMBODY
               |multicomment PROGRAMBODY
               |DEFINITION PROGRAMBODY
               |EVALUATION PROGRAMBODY
               |error PROGRAMBODY
               |rightCurlyB;

//definicion de los conjuntos
DEFINITION ::= CONJUNTO 
             | EXPRG 
             | separator separator;


CONJUNTO ::= conj colon id arrow NOTATION semicolon {: System.out.println("Nuevo conjunto"); :};

NOTATION ::= id virgulilla id
           | asciiChar virgulilla asciiChar
           | LISTVAL
           | ASCIIS;

//definicion de las expresiones regulares
EXPRG ::= id:n arrow  PREFIXREGEX:r semicolon
          {: 
            parser.ids++;
            AST finR = new AST(parser.ids, "#", null, null); 
            parser.ids++;
            AST newR = new AST(parser.ids, ".", (AST)r, finR);
            
            parser.rootT = newR;
            parser.rootT.generateAST((String) n);
            EXREGAN.trees.add((AST)r);
            EXREGAN.menu.addTree((String)n, EXREGAN.menu.getTrees());
            System.out.println("Nueva expresi칩n regular"); 
          :};


PREFIXREGEX ::= operatorAnd PREFIXREGEX:ri PREFIXREGEX:le
                {:
                    System.out.println("nuevo . P");
                    parser.ids++;
                    RESULT = new AST(parser.ids, ".", (AST)le, (AST)ri); 
                :}

              | operatorOr PREFIXREGEX:ri  PREFIXREGEX:le
                {:
                    System.out.println("nuevo | P");
                    parser.ids++;
                    RESULT = new AST(parser.ids, "|", (AST)le, (AST)ri); 
 
                :}

              | operatorZeroMore PREFIXREGEX:le
                {:
                    System.out.println("nuevo * P");
                    parser.ids++;
                    RESULT = new AST(parser.ids, "*", (AST)le, null); 

                :}

              | operatorOneMore  PREFIXREGEX:le
                {:
                    System.out.println("nuevo + P");
                    parser.ids++;
                    RESULT = new AST(parser.ids, "+", (AST)le, null); 

                :}

              | operatorZeroOne PREFIXREGEX:le
                {:
                    System.out.println("nuevo ? P");
                    parser.ids++;
                    RESULT = new AST(parser.ids, "?", (AST)le, null); 
 
                :}
              | leftCurlyB id:o rightCurlyB 
                {:
                    System.out.println("nuevo id"); 
                    
                    parser.ids++;
                    RESULT = new AST(parser.ids, o, null, null );

                :}
              | stringVal:o
                {:  
                    String contenido = (String)o;
                    //String [] concat=contenido.split("\"");//eliminando las comillas de la cadena para que no de error al generar el png
                    System.out.println("nuevo string"); 
                    
                    parser.ids++;
                    RESULT = new AST(parser.ids, contenido, null, null );

                :}
              | specialChar:o
                {:  
                    String contenido = (String)o;
                    System.out.println("nuevo specialChar"); 
                    
                    parser.ids++;
                    RESULT = new AST(parser.ids, contenido, null, null );

                :};







//lexemas a evaluar
EVALUATION ::= id colon stringVal semicolon {: System.out.println("Nuevo lexema a evaluar"); :};


//listas
LISTVAL ::= id comma LISTVAL
          | id;

ASCIIS ::= asciiChar comma ASCIIS
         | asciiChar;






               
